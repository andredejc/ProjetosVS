IF OBJECT_ID('TEMPDB..#TESTE','U') IS NOT NULL DROP TABLE #TESTE
GO

CREATE TABLE #TESTE(
	DT_VENDA DATE,
	CODIGO INT
)

INSERT INTO #TESTE 
VALUES	( '2017-04-10',1),( '2017-04-11',1),( '2017-04-12',1),( '2017-04-13',1),( '2017-04-15',1),
		( '2017-04-10',2),( '2017-04-15',2),( '2017-04-16',2),( '2017-04-17',2),( '2017-04-21',2),
		( '2017-04-12',3),( '2017-04-13',3),( '2017-04-14',3),( '2017-04-15',3),( '2017-04-17',3),
		( '2017-04-11',4),( '2017-04-12',4),( '2017-04-13',4),( '2017-04-19',4),( '2017-04-25',4)

		
SELECT DISTINCT
	CODIGO,	
	FIRST_VALUE(DT_VENDA) OVER(PARTITION BY CODIGO ORDER BY CODIGO) DATA_ENTRADA,
	LAST_VALUE(DT_VENDA) OVER(PARTITION BY CODIGO ORDER BY CODIGO) DATA_SAIDA 
FROM #TESTE

-- Se for inserido um valor de menor data depois de um valor de maior data, é possível pegar como FIRST_VALUE a menor data e o LAST_VALUE como maior data
-- utilizando UNBOUNDED PRECEDING e UNBOUNDED FOLLOWING.

SELECT DISTINCT
	CODIGO,	
	FIRST_VALUE(DT_VENDA) OVER(PARTITION BY CODIGO ORDER BY DT_VENDA ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) DATA_ENTRADA,
	LAST_VALUE(DT_VENDA) OVER(PARTITION BY CODIGO ORDER BY DT_VENDA ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) DATA_SAIDA
FROM #TESTE

-- O mesmo resultado da query anterior caso o SQL Server 2008.
WITH CTEMENOR AS(
	SELECT DISTINCT
		CODIGO,
		MIN(DT_VENDA) OVER(PARTITION BY CODIGO) AS MENOR	
	FROM #TESTE
),
CTEMAIOR AS(
	SELECT DISTINCT
		CODIGO,	
		MAX(DT_VENDA) OVER(PARTITION BY CODIGO) AS MAIOR
	FROM #TESTE
)
SELECT 
	A.CODIGO,
	A.MENOR AS DATA_ENTRADA,
	B.MAIOR AS DATA_SAIDA
FROM CTEMENOR AS A
	INNER JOIN CTEMAIOR AS B
		ON A.CODIGO = B.CODIGO